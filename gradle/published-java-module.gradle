/*
 * Hibernate, Relational Persistence for Idiomatic Java
 *
 * License: GNU Lesser General Public License (LGPL), version 2.1 or later
 * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html
 */

apply from: rootProject.file( 'gradle/java-module.gradle' )

apply plugin: 'maven-publish'
//apply from: rootProject.file( 'gradle/common-bintray-info.gradle' )
apply plugin: 'maven-publish-auth'

task sourcesJar(type: Jar) {
	from project.sourceSets.main.allSource
	manifest = project.tasks.jar.manifest
	classifier = 'sources'
}

task javadocJar(type: Jar) {
	from project.tasks.javadoc.outputs
	manifest = project.tasks.jar.manifest
	classifier = 'javadoc'
}

publishing {
	publications {
		publishedArtifacts( MavenPublication ) {
			from components.java

			artifact( sourcesJar ) {
				// todo : do these really need to be specified twice?
				classifier 'sources'
			}

			artifact( javadocJar ) {
				// todo : do these really need to be specified twice?
				classifier "javadoc"
			}
		}
	}
	// done here so that maven-publish-auth plugin can see the repo to apply auth details
	repositories {
		maven {
			name 'jboss-snapshots-repository'
			url 'https://repository.jboss.org/nexus/content/repositories/snapshots'
		}
	}
}

//bintray {
//	publications = ['publishedArtifacts']
//
//	pkg {
//		repo = 'maven'
//	}
//}

model {
	tasks.generatePomFileForPublishedArtifactsPublication {
		destination = file( "${buildDir}/generated-pom.xml" )
	}
}

apply plugin: org.hibernate.build.gradle.pubsign.MavenPublicationSigningPlugin

task publishSnapshots(dependsOn: publish)
//task release(dependsOn: bintrayUpload) {
task release(dependsOn: publish) {
	doFirst {
		println "Starting release for $project.name:$project.version"
	}
}
//
//if ( project.isSnapshot ) {
//	release.enabled = false
//	tasks.bintrayUpload {
//		enabled = false
//		doFirst {
//			throw new PublishException(
//					"Cannot publish SNAPSHOT versions to Bintray (bintrayUpload task was requested)"
//			)
//		}
//	}
//}
//else {
//	tasks.find { task -> task.name.startsWith( 'publish' ) }.each { task ->
//		task.enabled = false
//		task.doFirst {
//			throw new PublishException(
//					"Cannot publish release (non-SNAPSHOT) versions to JBoss snapshot repository (`$task.name` was requested)"
//			)
//		}
//	}
//}

afterEvaluate {

	// delay pom customization until project evaluation is complete

	PublishingExtension gradlePublishingExtension = project.extensions.getByType( PublishingExtension )

	gradlePublishingExtension.publications.withType( MavenPublication ).each { mavenPublication ->
		project.configure( mavenPublication ) {
			pom.withXml {
				asNode().appendNode( 'name', "Hibernate ORM - $mavenPublication.artifactId" )
				asNode().appendNode( 'description', project.description )

				Node licensesNode = asNode().appendNode( "licenses" )

				Node lgplLicenseNode = licensesNode.appendNode( "license" )
				lgplLicenseNode.appendNode( 'name', 'GNU Lesser General Public License' )
				lgplLicenseNode.appendNode( 'url', 'http://www.gnu.org/licenses/lgpl-2.1.html' )
				lgplLicenseNode.appendNode(
						'comments',
						'See discussion at http://hibernate.org/license for more details.'
				)
				lgplLicenseNode.appendNode( 'distribution', 'repo' )

				asNode().children().last() + {
					url 'http://hibernate.org'
					organization {
						name 'Hibernate.org'
						url 'http://hibernate.org'
					}
					issueManagement {
						system 'jira'
						url 'https://hibernate.atlassian.net/browse/HHH'
					}
					scm {
						url 'http://github.com/hibernate/hibernate-orm'
						connection 'scm:git:http://github.com/hibernate/hibernate-orm.git'
						developerConnection 'scm:git:git@github.com:hibernate/hibernate-orm.git'
					}
					developers {
						developer {
							id 'hibernate-team'
							name 'The Hibernate Development Team'
							organization 'Hibernate.org'
							organizationUrl 'http://hibernate.org'
						}
					}
				}

				// TEMPORARY : currently Gradle Publishing feature is exporting dependencies as 'runtime' scope,
				//      rather than 'compile'; fix that.
				if ( asNode().dependencies != null && asNode().dependencies.size() > 0 ) {
					asNode().dependencies[0].dependency.each {
						it.scope[0].value = 'compile'
					}
				}
			}
		}
	}
}